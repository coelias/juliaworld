["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$starts-with?","~$clojure.string","~$go","~$cljs.core.async.macros","~$dbg","~$gadjett.core","~$go-loop","^6","~$emits","~$cljs.compiler","~$*source-map-data*","^;","~$emit","^;"],"~:excludes",["~#set",[]],"~:name","~$klipse-clj.lang.clojure.guard","~:imports",null,"~:requires",["^ ","~$ana","~$cljs.analyzer","^E","^E","~$s","^4","^4","^4","^;","^;","~$cljs.core.async","^F"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$timeout","^F","~$<!","^F","^3","^4","~$chan","^F","^:","^;","^<","^;","^=","^;","~$put!","^F"],"~:defs",["^ ","~$watchdog",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","~:line",47,"~:column",7,"~:end-line",47,"~:end-column",15,"~:arglists",["~#list",["~$quote",["^W",[[]]]]]],"^@","~$klipse-clj.lang.clojure.guard/watchdog","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",15,"~:method-params",["^W",[[]]],"~:protocol-impl",null,"~:arglists-meta",["^W",[null,null]],"^S",1,"~:variadic?",false,"^R",47,"~:ret-tag","~$any","^T",47,"~:max-fixed-arity",0,"~:fn-var",true,"^V",["^W",["^X",["^W",[[]]]]]],"~$guard",["^ ","^O",null,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",52,"^S",3,"^T",52,"^U",8,"~:export",true,"^V",["^W",["^X",["^W",[["~$max-eval-duration"]]]]]],"^@","~$klipse-clj.lang.clojure.guard/guard","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",8,"^Z",["^W",[["^18"]]],"^[",null,"^17",true,"^10",["^W",[null,null]],"^S",1,"^11",false,"^R",51,"^12",["^?",[null,"~$clj-nil"]],"^T",52,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["^18"]]]]]],"~$tick",["^ ","^O",null,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",33,"^S",7,"^T",33,"^U",11,"^V",["^W",["^X",["^W",[[]]]]]],"^@","~$klipse-clj.lang.clojure.guard/tick","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",11,"^Z",["^W",[[]]],"^[",null,"^10",["^W",[null,null]],"^S",1,"^11",false,"^R",33,"^T",33,"^14",0,"^15",true,"^V",["^W",["^X",["^W",[[]]]]]],"~$runonce",["^ ","^O",null,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",26,"^S",7,"^T",26,"^U",14,"^V",["^W",["^X",["^W",[["~$f"]]]]]],"^@","~$klipse-clj.lang.clojure.guard/runonce","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",14,"^Z",["^W",[["~$f"]]],"^[",null,"^10",["^W",[null,null]],"^S",1,"^11",false,"^R",26,"^12","~$function","^T",26,"^14",1,"^15",true,"^V",["^W",["^X",["^W",[["~$f"]]]]]],"~$run-watchdog*",["^ ","^O",null,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",36,"^S",7,"^T",36,"^U",20,"^V",["^W",["^X",["^W",[[]]]]],"~:doc","reset the *watchdog-tick* to the current time once in a while"],"^@","~$klipse-clj.lang.clojure.guard/run-watchdog*","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",20,"^Z",["^W",[[]]],"^[",null,"^10",["^W",[null,null]],"^S",1,"^11",false,"^R",36,"^12","^13","^T",36,"^14",0,"^15",true,"^V",["^W",["^X",["^W",[[]]]]],"^1A","reset the *watchdog-tick* to the current time once in a while"],"~$watchdog-period",["^ ","^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",24,"^S",3,"^T",24,"^U",18,"^1A","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"^@","~$klipse-clj.lang.clojure.guard/watchdog-period","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",18,"^S",1,"^R",22,"^T",24,"~:tag","~$number","^1A","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"~$min-max-eval-duration",["^ ","^@","~$klipse-clj.lang.clojure.guard/min-max-eval-duration","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",21,"^S",1,"^T",21,"^U",27,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",21,"^S",6,"^T",21,"^U",27],"^1E","^1F"],"~$run-watchdog-once",["^ ","^@","~$klipse-clj.lang.clojure.guard/run-watchdog-once","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",45,"^S",1,"^T",45,"^U",23,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",45,"^S",6,"^T",45,"^U",23],"^1E","^1?"],"~$my-emits",["^ ","^O",null,"^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",59,"^S",7,"^T",59,"^U",15,"^V",["^W",["^X",["^W",[["^18","~$&","~$xs"]]]]],"^1A","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  ","~:top-fn",["^ ","^11",true,"~:fixed-arity",1,"^14",1,"^Z",[["^W",["^18","^1L"]]],"^V",["^W",[["^18","~$&","^1L"]]],"^10",["^W",[null]]]],"^@","~$klipse-clj.lang.clojure.guard/my-emits","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",15,"^1M",["^ ","^11",true,"^1N",1,"^14",1,"^Z",[["^W",["^18","^1L"]]],"^V",["^W",[["^18","~$&","^1L"]]],"^10",["^W",[null]]],"^Z",[["^W",["^18","^1L"]]],"^[",null,"^1N",1,"^10",["^W",[null]],"^S",1,"^11",true,"~:methods",[["^ ","^1N",1,"^11",true,"^1E","^1:"]],"^R",59,"^12","^13","^T",59,"^14",1,"^15",true,"^V",["^W",[["^18","~$&","^1L"]]],"^1A","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  "],"~$*watchdog-tick*",["^ ","^P",["^ ","^Q","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^R",19,"^S",3,"^T",19,"^U",18,"^1A","each time the watchdog has a chance to run, this var is set with the current time","~:dynamic",true],"^@","~$klipse-clj.lang.clojure.guard/*watchdog-tick*","^Q","target/public/cljs-out/dev/klipse_clj/lang/clojure/guard.cljs","^U",18,"^S",1,"^1R",true,"^R",17,"^T",19,"^1E","^13","^1A","each time the watchdog has a chance to run, this var is set with the current time"]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ ","~$gadjett","^8","^8","^8","^6","^6","^F","^F"],"~:cljs.analyzer/constants",["^ ","~:seen",["^?",["~:else","~:recur","~:gen-col"]],"~:order",["^1Z","^1Y","^1["]],"^1A","The basic idea is that the first time a klipse snippet's cljs is evaluated, we kick off a go-loop whose job is to wake up every 100ms and update *watchdog-tick* to say: this is the last time that i woke up!\n\n  And if (guard) gets run and notices that the watchdog hasn't been able to wake up within the last *max-eval-duration* milliseconds, it decides that we should kill the currently evaluating function, and does that by throwing an error.\n\n  and this doesn't kill go-loops created by users' snippet code, because those go-loops won't block the watchdog from running.\n  ","~:as-aliases",["^ "]]