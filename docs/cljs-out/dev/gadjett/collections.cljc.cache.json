["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ ","~$postwalk","~$clojure.walk","~$union","~$clojure.set","~$join","~$clojure.string","~$split-lines","^8","~$blank?","^8"],"~:excludes",["~#set",["~$abs"]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","^6","^6","^4","^4","^8","^8","~$zip","~$clojure.zip","^C","^C"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","^3","^4","^5","^6","^7","^8","^9","^8","^:","^8"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","~:line",485,"~:column",7,"~:end-line",485,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^P",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^>","~$gadjett.collections/unflatten-keys","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"~:method-params",["^P",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^L",1,"~:variadic?",false,"^K",485,"~:ret-tag",["^<",[null,"~$any"]],"^M",485,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",136,"^L",7,"^M",136,"^N",20,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"^>","~$gadjett.collections/sequence->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",136,"^X","~$clj","^M",136,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n  ~~~klipse\n  (sequence->map [10 20 30])\n  ~~~\n  "],"~$=without-keys?",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",37,"^L",7,"^M",37,"^N",21,"^O",["^P",["^Q",["^P",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^>","~$gadjett.collections/=without-keys?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["^14","^15","^16"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",37,"^X","^Y","^M",37,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^14","^15","^16"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",340,"^L",7,"^M",340,"^N",16,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^>","~$gadjett.collections/dissoc-in","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["~$m","~$p__20760"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",340,"^X",["^<",[null,"^12","^Y","~$clj-nil"]],"^M",340,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","^19","^1:","^1;"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",396,"^L",7,"^M",396,"^N",35,"^O",["^P",["^Q",["^P",[["~$coll","~$pred","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^>","~$gadjett.collections/split-by-predicate-positions","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",35,"^T",["^P",[["^1@","^1A","~$n","~$d"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",396,"^X","~$cljs.core/LazySeq","^M",396,"^Z",4,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",317,"^L",7,"^M",317,"^N",13,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^>","~$gadjett.collections/mapify","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^T",["^P",[["~$f","~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",317,"^X","^12","^M",317,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",429,"^L",7,"^M",429,"^N",14,"^O",["^P",["^Q",["^P",[["~$m1","~$m2"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^>","~$gadjett.collections/submap?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["^1G","^1H"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",429,"^X","~$boolean","^M",429,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^1G","^1H"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",365,"^L",7,"^M",365,"^N",16,"^O",["^P",["^Q",["^P",[["~$coll-of-lengths","~$&",["^ ","~:keys",["~$max-val","~$first-val"],"~:or",["^ ","^1N","~$infinity","^1O",0]]]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^W",true,"~:fixed-arity",1,"^Z",1,"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/positions","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^V",["^P",[null]]],"^T",[["^P",["^1L",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"~:methods",[["^ ","^1S",1,"^W",true,"~:tag","^1C"]],"^K",365,"^X","^Y","^M",365,"^Z",1,"^[",true,"^O",["^P",[["^1L","~$&",["^ ","^1M",["^1N","^1O"],"^1P",["^ ","^1N","^1Q","^1O",0]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",267,"^L",7,"^M",267,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/filter-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",267,"^X",["^<",[null,"^12","^Y"]],"^M",267,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the values of a map and keep only the (key, value) pairs for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",47,"^L",7,"^M",47,"^N",15,"^O",["^P",["^Q",["^P",[["~$vec"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^>","~$gadjett.collections/vec->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",15,"^T",["^P",[["^1Z"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",47,"^X",["^<",[null,"^12","^Y"]],"^M",47,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^1Z"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",205,"^L",7,"^M",205,"^N",19,"^O",["^P",["^Q",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1R",["^ ","^W",false,"^1S",4,"^Z",4,"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/assoc-cyclic","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^1R",["^ ","^W",false,"^1S",4,"^Z",4,"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^V",["^P",[null,null]]],"^T",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]],"^U",null,"^1S",4,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",3,"^W",false,"^1V",["^<",[null,"^12","^Y"]]],["^ ","^1S",4,"^W",false,"^1V",["^<",[null,"^12","^Y"]]]],"^K",205,"^M",205,"^Z",4,"^[",true,"^O",["^P",[["^1@","~$k","~$v"],["^1@","~$k","~$v","~$n"]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1Q",["^ ","^>","~$gadjett.collections/infinity","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^K",7,"^L",1,"^M",7,"^N",14,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",7,"^L",6,"^M",7,"^N",14],"^1V","~$js/Number"],"~$subsequence",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",444,"^L",7,"^M",444,"^N",18,"^O",["^P",["^Q",["^P",[["^1@","~$start","~$end"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^>","~$gadjett.collections/subsequence","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["^1@","^25","^26"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",444,"^X","^1C","^M",444,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^25","^26"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",625,"^L",7,"^M",625,"^N",14,"^O",["^P",["^Q",["^P",[["~$root"]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^>","~$gadjett.collections/edn-zip","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["^29"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",625,"^X","^Y","^M",625,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["^29"]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",691,"^L",7,"^M",691,"^N",22,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^>","~$gadjett.collections/fix-blank-lines","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",691,"^X","~$string","^M",691,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",307,"^L",7,"^M",307,"^N",20,"^O",["^P",["^Q",["^P",[["~$f","~$lst"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^>","~$gadjett.collections/map-to-object","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$f","^2?"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",307,"^X","^12","^M",307,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","^2?"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",524,"^L",7,"^M",524,"^N",17,"^O",["^P",["^Q",["^P",[["~$&","~$maps"]]]]],"^R"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2B"]]],"^O",["^P",[["~$&","^2B"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/deep-merge","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2B"]]],"^O",["^P",[["~$&","^2B"]]],"^V",["^P",[null]]],"^T",[["^P",["^2B"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V","^Y"]],"^K",524,"^X","^Y","^M",524,"^Z",0,"^[",true,"^O",["^P",[["~$&","^2B"]]],"^R"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",124,"^L",7,"^M",124,"^N",11,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^>","~$gadjett.collections/mean","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",11,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",124,"^X","~$number","^M",124,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",650,"^L",8,"^M",650,"^N",22,"~:private",true,"^O",["^P",["^Q",["^P",[["~$smap","~$loc"]]]]]],"^2H",true,"^>","~$gadjett.collections/loc-my-replace","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["^2I","^2J"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",650,"^X",["^<",[null,"^Y"]],"^M",650,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2I","^2J"]]]]]],"~$map-object-kv",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",100,"^L",7,"^M",100,"^N",20,"^O",["^P",["^Q",["^P",[["~$fk","~$fv","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^>","~$gadjett.collections/map-object-kv","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2M","^2N","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",100,"^X",["^<",[null,"^12","^Y"]],"^M",100,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^2M","^2N","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$compactize-map-recursive",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",251,"^L",7,"^M",251,"^N",31,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"^>","~$gadjett.collections/compactize-map-recursive","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",31,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",251,"^X","^Y","^M",251,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Remove from a map the entries whose values are `nil`.\n  If all the values of a nested map are `nil` the entrie is removed.\n~~~klipse\n\n(compactize-map-recursive {:x 1 :z {:a nil} :a {:b nil :c 2 :d {:e nil :f 2}}})\n~~~\n  "],"~$flatten-keys",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",474,"^L",7,"^M",474,"^N",19,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^>","~$gadjett.collections/flatten-keys","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",474,"^X",["^<",[null,"^12","^Y","~$cljs.core/IMap"]],"^M",474,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$scale",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",21,"^L",8,"^M",21,"^N",13,"^2H",true,"^O",["^P",["^Q",["^P",[["~$x","~$y"]]]]]],"^2H",true,"^>","~$gadjett.collections/scale","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^T",["^P",[["~$x","~$y"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",21,"^X",["^<",["^Y","^2F"]],"^M",21,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$x","~$y"]]]]]],"~$flatten-keys*",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",467,"^L",8,"^M",467,"^N",21,"^2H",true,"^O",["^P",["^Q",["^P",[["~$a","^19","~$m"]]]]]],"^2H",true,"^>","~$gadjett.collections/flatten-keys*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$a","^19","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",467,"^X",["^<",[null,"^12","^Y","^2T"]],"^M",467,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","^19","~$m"]]]]]],"~$almost=",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",26,"^L",7,"^M",26,"^N",14,"^O",["^P",["^Q",["^P",[["~$x","~$y"],["~$x","~$y","~$epsilon"]]]]],"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$x","~$y"],["~$x","~$y","^2Z"]],"^O",["^P",[["~$x","~$y"],["~$x","~$y","^2Z"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/almost=","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$x","~$y"],["~$x","~$y","^2Z"]],"^O",["^P",[["~$x","~$y"],["~$x","~$y","^2Z"]]],"^V",["^P",[null,null]]],"^T",[["~$x","~$y"],["~$x","~$y","^2Z"]],"^U",null,"^1S",3,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",2,"^W",false,"^1V","^Y"],["^ ","^1S",3,"^W",false,"^1V","^1J"]],"^K",26,"^M",26,"^Z",3,"^[",true,"^O",["^P",[["~$x","~$y"],["~$x","~$y","^2Z"]]]],"~$compactize-map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",239,"^L",7,"^M",239,"^N",21,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^>","~$gadjett.collections/compactize-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",239,"^X",["^<",[null,"^12","^Y"]],"^M",239,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",595,"^L",7,"^M",595,"^N",24,"^O",["^P",["^Q",["^P",[["^1A","^1@"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^>","~$gadjett.collections/partition-between","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",24,"^T",["^P",[["^1A","^1@"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",595,"^X","^1C","^M",595,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^1A","^1@"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",496,"^L",7,"^M",496,"^N",20,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^>","~$gadjett.collections/take-from-map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$n","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",496,"^X",["^<",[null,"^Y"]],"^M",496,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$map-nested-vals",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",760,"^L",7,"^M",760,"^N",22,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"^>","~$gadjett.collections/map-nested-vals","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",760,"^X",["^<",[null,"^Y"]],"^M",760,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Map the values of a nested map.\n~~~klipse\n  (map-nested-vals first {:a [1 2 3]\n                          :b {:c [4 5 6]}})\n~~~\n  "],"~$compact",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",724,"^L",11,"^M",724,"^N",18,"^O",["^P",["^Q",["^P",[["~$x","~$&",["^ ","^1M",["~$max-elements-in-coll","~$max-chars-in-str"],"^1P",["^ ","^39",10,"^3:",20],"^1:","~$args"]]]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$x",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^O",["^P",[["~$x","~$&",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/compact","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$x",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^O",["^P",[["~$x","~$&",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^V",["^P",[null]]],"^T",[["^P",["~$x",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",5,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V",["^<",[null,"^Y","~$cljs.core/Keyword","^1C","^2F","^2=","^1>"]]]],"^K",724,"^X","^Y","^M",724,"^Z",1,"^[",true,"^O",["^P",[["~$x","~$&",["^ ","^1M",["^39","^3:"],"^1P",["^ ","^39",10,"^3:",20],"^1:","^3;"]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$substr",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",790,"^L",7,"^M",790,"^N",13,"^O",["^P",["^Q",["^P",[["~$s","^25"],["~$s","^25","^26"]]]]],"^R","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  ","^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$s","^25"],["~$s","^25","^26"]],"^O",["^P",[["~$s","^25"],["~$s","^25","^26"]]],"^V",["^P",[null,null]]]],"^>","~$gadjett.collections/substr","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",13,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["~$s","^25"],["~$s","^25","^26"]],"^O",["^P",[["~$s","^25"],["~$s","^25","^26"]]],"^V",["^P",[null,null]]],"^T",[["~$s","^25"],["~$s","^25","^26"]],"^U",null,"^1S",3,"^V",["^P",[null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",2,"^W",false,"^1V","^2="],["^ ","^1S",3,"^W",false,"^1V","^2="]],"^K",790,"^M",790,"^Z",3,"^[",true,"^O",["^P",[["~$s","^25"],["~$s","^25","^26"]]],"^R","Like clojure.core/subs but prevents some exceptions when the `start` or `end` are out of bound.\n~~~klipse\n  (subs \"\" -2)\n~~~\n\n  "],"~$map-with-index",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",330,"^L",7,"^M",330,"^N",21,"^O",["^P",["^Q",["^P",[["~$s","~$idx-key","~$val-key"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^>","~$gadjett.collections/map-with-index","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$s","^3A","^3B"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",330,"^X","^Y","^M",330,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["~$s","^3A","^3B"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",90,"^L",7,"^M",90,"^N",26,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/map-object-with-key","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",26,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",90,"^X",["^<",[null,"^12","^Y"]],"^M",90,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",515,"^L",8,"^M",515,"^N",19,"^2H",true,"^O",["^P",["^Q",["^P",[["~$&","^2B"]]]]],"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2B"]]],"^O",["^P",[["~$&","^2B"]]],"^V",["^P",[null]]]],"^2H",true,"^>","~$gadjett.collections/deep-merge*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",19,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^2B"]]],"^O",["^P",[["~$&","^2B"]]],"^V",["^P",[null]]],"^T",[["^P",["^2B"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V",["^<",["^Y","^1>"]]]],"^K",515,"^X","^Y","^M",515,"^Z",0,"^[",true,"^O",["^P",[["~$&","^2B"]]]],"~$range-till-end",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",169,"^L",7,"^M",169,"^N",21,"^O",["^P",["^Q",["^P",[["~$&","^3;"]]]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^3;"]]],"^O",["^P",[["~$&","^3;"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/range-till-end","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^1R",["^ ","^W",true,"^1S",0,"^Z",0,"^T",[["^P",["^3;"]]],"^O",["^P",[["~$&","^3;"]]],"^V",["^P",[null]]],"^T",[["^P",["^3;"]]],"^U",null,"^1S",0,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",0,"^W",true,"^1V","^1C"]],"^K",169,"^X","^Y","^M",169,"^Z",0,"^[",true,"^O",["^P",[["~$&","^3;"]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",294,"^L",7,"^M",294,"^N",21,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^>","~$gadjett.collections/nearest-of-seq","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",21,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",294,"^X",["^<",[null,"^1C"]],"^M",294,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",164,"^L",8,"^M",164,"^N",22,"^2H",true,"^O",["^P",["^Q",["^P",[["^26"],["^25","^26"],["^25","^26","~$steps"]]]]],"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["^26"],["^25","^26"],["^25","^26","^3M"]],"^O",["^P",[["^26"],["^25","^26"],["^25","^26","^3M"]]],"^V",["^P",[null,null,null]]]],"^2H",true,"^>","~$gadjett.collections/range-with-end","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^1R",["^ ","^W",false,"^1S",3,"^Z",3,"^T",[["^26"],["^25","^26"],["^25","^26","^3M"]],"^O",["^P",[["^26"],["^25","^26"],["^25","^26","^3M"]]],"^V",["^P",[null,null,null]]],"^T",[["^26"],["^25","^26"],["^25","^26","^3M"]],"^U",null,"^1S",3,"^V",["^P",[null,null,null]],"^L",1,"^W",false,"^1U",[["^ ","^1S",1,"^W",false,"^1V","~$cljs.core/IVector"],["^ ","^1S",2,"^W",false,"^1V","^3O"],["^ ","^1S",3,"^W",false,"^1V","^3O"]],"^K",164,"^M",164,"^Z",3,"^[",true,"^O",["^P",[["^26"],["^25","^26"],["^25","^26","^3M"]]]],"~$branches-and-leaves",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",559,"^L",7,"^M",559,"^N",26,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^>","~$gadjett.collections/branches-and-leaves","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",26,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",559,"^X",["^<",[null,"^Y"]],"^M",559,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$deep-merge-with",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",545,"^L",7,"^M",545,"^N",22,"^O",["^P",["^Q",["^P",[["~$g","~$&","^2B"]]]]],"^R","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n","^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2B"]]],"^O",["^P",[["~$g","~$&","^2B"]]],"^V",["^P",[null]]]],"^>","~$gadjett.collections/deep-merge-with","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2B"]]],"^O",["^P",[["~$g","~$&","^2B"]]],"^V",["^P",[null]]],"^T",[["^P",["~$g","^2B"]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V","^Y"]],"^K",545,"^X","^Y","^M",545,"^Z",1,"^[",true,"^O",["^P",[["~$g","~$&","^2B"]]],"^R","Like merge-with but deep.\n~~~klipse\n(deep-merge-with concat\n                 {:x {:b [1]\n                      :a [1]}}\n                 {:x {:a [3 4]}})\n~~~\n"],"~$remove-blank-lines",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",709,"^L",7,"^M",709,"^N",25,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^>","~$gadjett.collections/remove-blank-lines","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",25,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",709,"^X","^2=","^M",709,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$select-vals",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",809,"^L",7,"^M",809,"^N",18,"^O",["^P",["^Q",["^P",[["~$map","~$keyseq"]]]]]],"^>","~$gadjett.collections/select-vals","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["^3W","^3X"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",809,"^X",["^<",["~$cljs.core/ValSeq","^1>"]],"^M",809,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^3W","^3X"]]]]]],"~$sequence-of-maps->map",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",146,"^L",7,"^M",146,"^N",28,"^O",["^P",["^Q",["^P",[["^1@","~$key-fn","~$val-fn"]]]]],"^R","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"^>","~$gadjett.collections/sequence-of-maps->map","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",28,"^T",["^P",[["^1@","^40","^41"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",146,"^X",["^<",[null,"^Y"]],"^M",146,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^40","^41"]]]]],"^R","Converts a sequence of maps into a map where:\n\n  - the keys are extracted from the maps using `key-fn`\n  - the vals extracted from the maps using `val-fn`  \n  \n  ~~~klipse\n  (sequence-of-maps->map [{:key :price :value 19}\n                          {:key :quantity :value 100}]\n                          :key :value)\n  ~~~\n  "],"~$filter-branches",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",573,"^L",7,"^M",573,"^N",22,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^>","~$gadjett.collections/filter-branches","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",22,"^T",["^P",[["~$m","~$p"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",573,"^X","^1C","^M",573,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$select-keys-in-order",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",804,"^L",7,"^M",804,"^N",27,"^O",["^P",["^Q",["^P",[["~$m","^3X"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^>","~$gadjett.collections/select-keys-in-order","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",27,"^T",["^P",[["~$m","^3X"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",804,"^X","^1C","^M",804,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$m","^3X"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$comment?",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",672,"^L",8,"^M",672,"^N",16,"^2H",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"^2H",true,"^>","~$gadjett.collections/comment?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",672,"^X",["^<",["^12","^3O","^Y","~$cljs.core/MetaFn","^1>"]],"^M",672,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",585,"^L",7,"^M",585,"^N",20,"^O",["^P",["^Q",["^P",[["~$v","~$idx"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^>","~$gadjett.collections/out-of-bound?","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["~$v","^4;"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",585,"^X","^1J","^M",585,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$v","^4;"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",57,"^L",7,"^M",57,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^>","~$gadjett.collections/map-2d-vec","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",57,"^X","^1C","^M",57,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",380,"^L",7,"^M",380,"^N",25,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^>","~$gadjett.collections/split-by-predicate","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",25,"^T",["^P",[["^1@","^1A","~$n"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",380,"^X","^1C","^M",380,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^1@","^1A","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^=",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",10,"^L",7,"^M",10,"^N",10,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^>","~$gadjett.collections/abs","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",10,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",10,"^X","^Y","^M",10,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$deep-merge-with*",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",536,"^L",8,"^M",536,"^N",24,"^2H",true,"^O",["^P",["^Q",["^P",[["~$g","~$&","^2B"]]]]],"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2B"]]],"^O",["^P",[["~$g","~$&","^2B"]]],"^V",["^P",[null]]]],"^2H",true,"^>","~$gadjett.collections/deep-merge-with*","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",24,"^1R",["^ ","^W",true,"^1S",1,"^Z",1,"^T",[["^P",["~$g","^2B"]]],"^O",["^P",[["~$g","~$&","^2B"]]],"^V",["^P",[null]]],"^T",[["^P",["~$g","^2B"]]],"^U",null,"^1S",1,"^V",["^P",[null]],"^L",1,"^W",true,"^1U",[["^ ","^1S",1,"^W",true,"^1V","^Y"]],"^K",536,"^X","^Y","^M",536,"^Z",1,"^[",true,"^O",["^P",[["~$g","~$&","^2B"]]]],"~$join-them",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",773,"^L",7,"^M",773,"^N",16,"^O",["^P",["^Q",["^P",[["~$fns","~$colls"]]]]],"^R","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"^>","~$gadjett.collections/join-them","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",16,"^T",["^P",[["^4E","^4F"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",773,"^X",["^<",["^3Z","^1>"]],"^M",773,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^4E","^4F"]]]]],"^R","Join a sequence of collections `colls` according to function equality.\n   `fns` - a sequence of functions\n   `colls` - a sequence of collections\n~~~klipse\n(let [a [{:id 1 :price 19} {:id 2 :price 3}]\n        b [{:guid 1 :quantity 13}]]\n     (join-them [:id :guid] [a b]))\n~~~\n"],"~$append-cyclic",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",189,"^L",7,"^M",189,"^N",20,"^O",["^P",["^Q",["^P",[["^2?","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^>","~$gadjett.collections/append-cyclic","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2?","~$a"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",189,"^X",["^<",[null,"^1C"]],"^M",189,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2?","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$select-vals-in-order",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",812,"^L",7,"^M",812,"^N",27,"^O",["^P",["^Q",["^P",[["^3W","^19"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"^>","~$gadjett.collections/select-vals-in-order","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",27,"^T",["^P",[["^3W","^19"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",812,"^X",["^<",[null,"^Y"]],"^M",812,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^3W","^19"]]]]],"^R","Thanks [Jay Fields](http://blog.jayfields.com/2011/01/clojure-select-keys-select-values-and.html)"],"~$collify",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",611,"^L",7,"^M",611,"^N",14,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^>","~$gadjett.collections/collify","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",14,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",611,"^X",["^<",[null,"~$cljs.core/List"]],"^M",611,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",68,"^L",7,"^M",68,"^N",20,"^O",["^P",["^Q",["^P",[["^2M","^2N","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^>","~$gadjett.collections/map-2d-vec-kv","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^2M","^2N","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",68,"^X","^1C","^M",68,"^Z",3,"^[",true,"^O",["^P",["^Q",["^P",[["^2M","^2N","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",227,"^L",7,"^M",227,"^N",18,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^>","~$gadjett.collections/max-and-min","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",18,"^T",["^P",[["~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",227,"^X",["^<",["^3O","^Y"]],"^M",227,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",456,"^L",7,"^M",456,"^N",15,"^O",["^P",["^Q",["^P",[["~$s","~$element"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^>","~$gadjett.collections/index-of","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",15,"^T",["^P",[["~$s","^4T"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",456,"^X",["^<",["^Y","^2F"]],"^M",456,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$s","^4T"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",282,"^L",7,"^M",282,"^N",20,"^O",["^P",["^Q",["^P",[["~$ss","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^>","~$gadjett.collections/nearest-of-ss","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",20,"^T",["^P",[["^4W","~$x"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",282,"^X","^Y","^M",282,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^4W","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",110,"^L",7,"^M",110,"^N",28,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^>","~$gadjett.collections/map-reverse-hierarchy","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",28,"^T",["^P",[["~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",110,"^X",["^<",["^Y","^2T"]],"^M",110,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",675,"^L",7,"^M",675,"^N",29,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^>","~$gadjett.collections/remove-ending-comments","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",29,"^T",["^P",[["~$s"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",675,"^X","^2=","^M",675,"^Z",1,"^[",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"aa\", \"  \", \"bb\" \"; this comment should not appear\"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",80,"^L",7,"^M",80,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^>","~$gadjett.collections/map-object","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["~$f","~$m"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",80,"^X",["^<",[null,"^12","^Y"]],"^M",80,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$=set",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",33,"^L",8,"^M",33,"^N",12,"^2H",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"^2H",true,"^>","~$gadjett.collections/=set","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",12,"^T",["^P",[["~$a","~$b"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",33,"^X","^1J","^M",33,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]]],"~$my-replace",["^ ","^H",null,"^I",["^ ","^J","/home/runner/work/juliaworld/juliaworld/target/public/cljs-out/dev/gadjett/collections.cljc","^K",657,"^L",7,"^M",657,"^N",17,"^O",["^P",["^Q",["^P",[["^2I","~$form"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^>","~$gadjett.collections/my-replace","^J","target/public/cljs-out/dev/gadjett/collections.cljc","^N",17,"^T",["^P",[["^2I","^56"]]],"^U",null,"^V",["^P",[null,null]],"^L",1,"^W",false,"^K",657,"^X","^Y","^M",657,"^Z",2,"^[",true,"^O",["^P",["^Q",["^P",[["^2I","^56"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:cljs.spec/registry-ref",[],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^<",["~:max-elements-in-coll","~:else","~:max-chars-in-str","~:first-val","~:branches","~:leaves","~:max-val"]],"~:order",["^5B","^5?","^5@","^5A","^5<","^5>","^5="]],"^R",null,"~:as-aliases",["^ "]]